#include <node.h>
#include "oled.h"
#include "bcm2835.h"
#include <stdlib.h>
#include <string.h>
#include <node_buffer.h>
using namespace v8;
using namespace node;

Persistent<Function> OLED::constructor;
uint8_t *buffer;
uint8_t font[] = {
        0x00, 0x00, 0x00, 0x00, 0x00,
	0x3E, 0x5B, 0x4F, 0x5B, 0x3E,
	0x3E, 0x6B, 0x4F, 0x6B, 0x3E,
	0x1C, 0x3E, 0x7C, 0x3E, 0x1C,
	0x18, 0x3C, 0x7E, 0x3C, 0x18,
	0x1C, 0x57, 0x7D, 0x57, 0x1C,
	0x1C, 0x5E, 0x7F, 0x5E, 0x1C,
	0x00, 0x18, 0x3C, 0x18, 0x00,
	0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
	0x00, 0x18, 0x24, 0x18, 0x00,
	0xFF, 0xE7, 0xDB, 0xE7, 0xFF,
	0x30, 0x48, 0x3A, 0x06, 0x0E,
	0x26, 0x29, 0x79, 0x29, 0x26,
	0x40, 0x7F, 0x05, 0x05, 0x07,
	0x40, 0x7F, 0x05, 0x25, 0x3F,
	0x5A, 0x3C, 0xE7, 0x3C, 0x5A,
	0x7F, 0x3E, 0x1C, 0x1C, 0x08,
	0x08, 0x1C, 0x1C, 0x3E, 0x7F,
	0x14, 0x22, 0x7F, 0x22, 0x14,
	0x5F, 0x5F, 0x00, 0x5F, 0x5F,
	0x06, 0x09, 0x7F, 0x01, 0x7F,
	0x00, 0x66, 0x89, 0x95, 0x6A,
	0x60, 0x60, 0x60, 0x60, 0x60,
	0x94, 0xA2, 0xFF, 0xA2, 0x94,
	0x08, 0x04, 0x7E, 0x04, 0x08,
	0x10, 0x20, 0x7E, 0x20, 0x10,
	0x08, 0x08, 0x2A, 0x1C, 0x08,
	0x08, 0x1C, 0x2A, 0x08, 0x08,
	0x1E, 0x10, 0x10, 0x10, 0x10,
	0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
	0x30, 0x38, 0x3E, 0x38, 0x30,
	0x06, 0x0E, 0x3E, 0x0E, 0x06,
	0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x5F, 0x00, 0x00,
	0x00, 0x07, 0x00, 0x07, 0x00,
	0x14, 0x7F, 0x14, 0x7F, 0x14,
	0x24, 0x2A, 0x7F, 0x2A, 0x12,
	0x23, 0x13, 0x08, 0x64, 0x62,
	0x36, 0x49, 0x56, 0x20, 0x50,
	0x00, 0x08, 0x07, 0x03, 0x00,
	0x00, 0x1C, 0x22, 0x41, 0x00,
	0x00, 0x41, 0x22, 0x1C, 0x00,
	0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
	0x08, 0x08, 0x3E, 0x08, 0x08,
	0x00, 0x80, 0x70, 0x30, 0x00,
	0x08, 0x08, 0x08, 0x08, 0x08,
	0x00, 0x00, 0x60, 0x60, 0x00,
	0x20, 0x10, 0x08, 0x04, 0x02,
	0x3E, 0x51, 0x49, 0x45, 0x3E,
	0x00, 0x42, 0x7F, 0x40, 0x00,
	0x72, 0x49, 0x49, 0x49, 0x46,
	0x21, 0x41, 0x49, 0x4D, 0x33,
	0x18, 0x14, 0x12, 0x7F, 0x10,
	0x27, 0x45, 0x45, 0x45, 0x39,
	0x3C, 0x4A, 0x49, 0x49, 0x31,
	0x41, 0x21, 0x11, 0x09, 0x07,
	0x36, 0x49, 0x49, 0x49, 0x36,
	0x46, 0x49, 0x49, 0x29, 0x1E,
	0x00, 0x00, 0x14, 0x00, 0x00,
	0x00, 0x40, 0x34, 0x00, 0x00,
	0x00, 0x08, 0x14, 0x22, 0x41,
	0x14, 0x14, 0x14, 0x14, 0x14,
	0x00, 0x41, 0x22, 0x14, 0x08,
	0x02, 0x01, 0x59, 0x09, 0x06,
	0x3E, 0x41, 0x5D, 0x59, 0x4E,
	0x7C, 0x12, 0x11, 0x12, 0x7C,
	0x7F, 0x49, 0x49, 0x49, 0x36,
	0x3E, 0x41, 0x41, 0x41, 0x22,
	0x7F, 0x41, 0x41, 0x41, 0x3E,
	0x7F, 0x49, 0x49, 0x49, 0x41,
	0x7F, 0x09, 0x09, 0x09, 0x01,
	0x3E, 0x41, 0x41, 0x51, 0x73,
	0x7F, 0x08, 0x08, 0x08, 0x7F,
	0x00, 0x41, 0x7F, 0x41, 0x00,
	0x20, 0x40, 0x41, 0x3F, 0x01,
	0x7F, 0x08, 0x14, 0x22, 0x41,
	0x7F, 0x40, 0x40, 0x40, 0x40,
	0x7F, 0x02, 0x1C, 0x02, 0x7F,
	0x7F, 0x04, 0x08, 0x10, 0x7F,
	0x3E, 0x41, 0x41, 0x41, 0x3E,
	0x7F, 0x09, 0x09, 0x09, 0x06,
	0x3E, 0x41, 0x51, 0x21, 0x5E,
	0x7F, 0x09, 0x19, 0x29, 0x46,
	0x26, 0x49, 0x49, 0x49, 0x32,
	0x03, 0x01, 0x7F, 0x01, 0x03,
	0x3F, 0x40, 0x40, 0x40, 0x3F,
	0x1F, 0x20, 0x40, 0x20, 0x1F,
	0x3F, 0x40, 0x38, 0x40, 0x3F,
	0x63, 0x14, 0x08, 0x14, 0x63,
	0x03, 0x04, 0x78, 0x04, 0x03,
	0x61, 0x59, 0x49, 0x4D, 0x43,
	0x00, 0x7F, 0x41, 0x41, 0x41,
	0x02, 0x04, 0x08, 0x10, 0x20,
	0x00, 0x41, 0x41, 0x41, 0x7F,
	0x04, 0x02, 0x01, 0x02, 0x04,
	0x40, 0x40, 0x40, 0x40, 0x40,
	0x00, 0x03, 0x07, 0x08, 0x00,
	0x20, 0x54, 0x54, 0x78, 0x40,
	0x7F, 0x28, 0x44, 0x44, 0x38,
	0x38, 0x44, 0x44, 0x44, 0x28,
	0x38, 0x44, 0x44, 0x28, 0x7F,
	0x38, 0x54, 0x54, 0x54, 0x18,
	0x00, 0x08, 0x7E, 0x09, 0x02,
	0x18, 0xA4, 0xA4, 0x9C, 0x78,
	0x7F, 0x08, 0x04, 0x04, 0x78,
	0x00, 0x44, 0x7D, 0x40, 0x00,
	0x20, 0x40, 0x40, 0x3D, 0x00,
	0x7F, 0x10, 0x28, 0x44, 0x00,
	0x00, 0x41, 0x7F, 0x40, 0x00,
	0x7C, 0x04, 0x78, 0x04, 0x78,
	0x7C, 0x08, 0x04, 0x04, 0x78,
	0x38, 0x44, 0x44, 0x44, 0x38,
	0xFC, 0x18, 0x24, 0x24, 0x18,
	0x18, 0x24, 0x24, 0x18, 0xFC,
	0x7C, 0x08, 0x04, 0x04, 0x08,
	0x48, 0x54, 0x54, 0x54, 0x24,
	0x04, 0x04, 0x3F, 0x44, 0x24,
	0x3C, 0x40, 0x40, 0x20, 0x7C,
	0x1C, 0x20, 0x40, 0x20, 0x1C,
	0x3C, 0x40, 0x30, 0x40, 0x3C,
	0x44, 0x28, 0x10, 0x28, 0x44,
	0x4C, 0x90, 0x90, 0x90, 0x7C,
	0x44, 0x64, 0x54, 0x4C, 0x44,
	0x00, 0x08, 0x36, 0x41, 0x00,
	0x00, 0x00, 0x77, 0x00, 0x00,
	0x00, 0x41, 0x36, 0x08, 0x00,
	0x02, 0x01, 0x02, 0x04, 0x02,
	0x3C, 0x26, 0x23, 0x26, 0x3C,
	0x1E, 0xA1, 0xA1, 0x61, 0x12,
	0x3A, 0x40, 0x40, 0x20, 0x7A,
	0x38, 0x54, 0x54, 0x55, 0x59,
	0x21, 0x55, 0x55, 0x79, 0x41,
	0x21, 0x54, 0x54, 0x78, 0x41,
	0x21, 0x55, 0x54, 0x78, 0x40,
	0x20, 0x54, 0x55, 0x79, 0x40,
	0x0C, 0x1E, 0x52, 0x72, 0x12,
	0x39, 0x55, 0x55, 0x55, 0x59,
	0x39, 0x54, 0x54, 0x54, 0x59,
	0x39, 0x55, 0x54, 0x54, 0x58,
	0x00, 0x00, 0x45, 0x7C, 0x41,
	0x00, 0x02, 0x45, 0x7D, 0x42,
	0x00, 0x01, 0x45, 0x7C, 0x40,
	0xF0, 0x29, 0x24, 0x29, 0xF0,
	0xF0, 0x28, 0x25, 0x28, 0xF0,
	0x7C, 0x54, 0x55, 0x45, 0x00,
	0x20, 0x54, 0x54, 0x7C, 0x54,
	0x7C, 0x0A, 0x09, 0x7F, 0x49,
	0x32, 0x49, 0x49, 0x49, 0x32,
	0x32, 0x48, 0x48, 0x48, 0x32,
	0x32, 0x4A, 0x48, 0x48, 0x30,
	0x3A, 0x41, 0x41, 0x21, 0x7A,
	0x3A, 0x42, 0x40, 0x20, 0x78,
	0x00, 0x9D, 0xA0, 0xA0, 0x7D,
	0x39, 0x44, 0x44, 0x44, 0x39,
	0x3D, 0x40, 0x40, 0x40, 0x3D,
	0x3C, 0x24, 0xFF, 0x24, 0x24,
	0x48, 0x7E, 0x49, 0x43, 0x66,
	0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
	0xFF, 0x09, 0x29, 0xF6, 0x20,
	0xC0, 0x88, 0x7E, 0x09, 0x03,
	0x20, 0x54, 0x54, 0x79, 0x41,
	0x00, 0x00, 0x44, 0x7D, 0x41,
	0x30, 0x48, 0x48, 0x4A, 0x32,
	0x38, 0x40, 0x40, 0x22, 0x7A,
	0x00, 0x7A, 0x0A, 0x0A, 0x72,
	0x7D, 0x0D, 0x19, 0x31, 0x7D,
	0x26, 0x29, 0x29, 0x2F, 0x28,
	0x26, 0x29, 0x29, 0x29, 0x26,
	0x30, 0x48, 0x4D, 0x40, 0x20,
	0x38, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x38,
	0x2F, 0x10, 0xC8, 0xAC, 0xBA,
	0x2F, 0x10, 0x28, 0x34, 0xFA,
	0x00, 0x00, 0x7B, 0x00, 0x00,
	0x08, 0x14, 0x2A, 0x14, 0x22,
	0x22, 0x14, 0x2A, 0x14, 0x08,
	0xAA, 0x00, 0x55, 0x00, 0xAA,
	0xAA, 0x55, 0xAA, 0x55, 0xAA,
	0x00, 0x00, 0x00, 0xFF, 0x00,
	0x10, 0x10, 0x10, 0xFF, 0x00,
	0x14, 0x14, 0x14, 0xFF, 0x00,
	0x10, 0x10, 0xFF, 0x00, 0xFF,
	0x10, 0x10, 0xF0, 0x10, 0xF0,
	0x14, 0x14, 0x14, 0xFC, 0x00,
	0x14, 0x14, 0xF7, 0x00, 0xFF,
	0x00, 0x00, 0xFF, 0x00, 0xFF,
	0x14, 0x14, 0xF4, 0x04, 0xFC,
	0x14, 0x14, 0x17, 0x10, 0x1F,
	0x10, 0x10, 0x1F, 0x10, 0x1F,
	0x14, 0x14, 0x14, 0x1F, 0x00,
	0x10, 0x10, 0x10, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x1F, 0x10,
	0x10, 0x10, 0x10, 0x1F, 0x10,
	0x10, 0x10, 0x10, 0xF0, 0x10,
	0x00, 0x00, 0x00, 0xFF, 0x10,
	0x10, 0x10, 0x10, 0x10, 0x10,
	0x10, 0x10, 0x10, 0xFF, 0x10,
	0x00, 0x00, 0x00, 0xFF, 0x14,
	0x00, 0x00, 0xFF, 0x00, 0xFF,
	0x00, 0x00, 0x1F, 0x10, 0x17,
	0x00, 0x00, 0xFC, 0x04, 0xF4,
	0x14, 0x14, 0x17, 0x10, 0x17,
	0x14, 0x14, 0xF4, 0x04, 0xF4,
	0x00, 0x00, 0xFF, 0x00, 0xF7,
	0x14, 0x14, 0x14, 0x14, 0x14,
	0x14, 0x14, 0xF7, 0x00, 0xF7,
	0x14, 0x14, 0x14, 0x17, 0x14,
	0x10, 0x10, 0x1F, 0x10, 0x1F,
	0x14, 0x14, 0x14, 0xF4, 0x14,
	0x10, 0x10, 0xF0, 0x10, 0xF0,
	0x00, 0x00, 0x1F, 0x10, 0x1F,
	0x00, 0x00, 0x00, 0x1F, 0x14,
	0x00, 0x00, 0x00, 0xFC, 0x14,
	0x00, 0x00, 0xF0, 0x10, 0xF0,
	0x10, 0x10, 0xFF, 0x10, 0xFF,
	0x14, 0x14, 0x14, 0xFF, 0x14,
	0x10, 0x10, 0x10, 0x1F, 0x00,
	0x00, 0x00, 0x00, 0xF0, 0x10,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
	0xFF, 0xFF, 0xFF, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xFF, 0xFF,
	0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
	0x38, 0x44, 0x44, 0x38, 0x44,
	0x7C, 0x2A, 0x2A, 0x3E, 0x14,
	0x7E, 0x02, 0x02, 0x06, 0x06,
	0x02, 0x7E, 0x02, 0x7E, 0x02,
	0x63, 0x55, 0x49, 0x41, 0x63,
	0x38, 0x44, 0x44, 0x3C, 0x04,
	0x40, 0x7E, 0x20, 0x1E, 0x20,
	0x06, 0x02, 0x7E, 0x02, 0x02,
	0x99, 0xA5, 0xE7, 0xA5, 0x99,
	0x1C, 0x2A, 0x49, 0x2A, 0x1C,
	0x4C, 0x72, 0x01, 0x72, 0x4C,
	0x30, 0x4A, 0x4D, 0x4D, 0x30,
	0x30, 0x48, 0x78, 0x48, 0x30,
	0xBC, 0x62, 0x5A, 0x46, 0x3D,
	0x3E, 0x49, 0x49, 0x49, 0x00,
	0x7E, 0x01, 0x01, 0x01, 0x7E,
	0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
	0x44, 0x44, 0x5F, 0x44, 0x44,
	0x40, 0x51, 0x4A, 0x44, 0x40,
	0x40, 0x44, 0x4A, 0x51, 0x40,
	0x00, 0x00, 0xFF, 0x01, 0x03,
	0xE0, 0x80, 0xFF, 0x00, 0x00,
	0x08, 0x08, 0x6B, 0x6B, 0x08,
	0x36, 0x12, 0x36, 0x24, 0x36,
	0x06, 0x0F, 0x09, 0x0F, 0x06,
	0x00, 0x00, 0x18, 0x18, 0x00,
	0x00, 0x00, 0x10, 0x10, 0x00,
	0x30, 0x40, 0xFF, 0x01, 0x01,
	0x00, 0x1F, 0x01, 0x01, 0x1E,
	0x00, 0x19, 0x1D, 0x17, 0x12,
	0x00, 0x3C, 0x3C, 0x3C, 0x3C,
	0x00, 0x00, 0x00, 0x00, 0x00
};


OLED::OLED(){

}
OLED::~OLED(){
  bcm2835_spi_end();
  bcm2835_close();
}

void OLED::Init(Handle<Object> exports){
    Local<FunctionTemplate> tpl = FunctionTemplate::New(New);
    tpl->SetClassName(String::NewSymbol("OLED"));
    tpl->InstanceTemplate()->SetInternalFieldCount(1);
    
    tpl->PrototypeTemplate()->Set(String::NewSymbol("setup"),
        FunctionTemplate::New(setup)->GetFunction());
    tpl->PrototypeTemplate()->Set(String::NewSymbol("writePixel"),
        FunctionTemplate::New(writePixel)->GetFunction());
    tpl->PrototypeTemplate()->Set(String::NewSymbol("fill"),
        FunctionTemplate::New(fill)->GetFunction());
    tpl->PrototypeTemplate()->Set(String::NewSymbol("gotoxy"),
        FunctionTemplate::New(gotoxy)->GetFunction());    
    tpl->PrototypeTemplate()->Set(String::NewSymbol("text"),
        FunctionTemplate::New(text)->GetFunction()); 
    tpl->PrototypeTemplate()->Set(String::NewSymbol("display"),
        FunctionTemplate::New(display)->GetFunction()); 
    constructor = Persistent<Function>::New(tpl->GetFunction());
    exports->Set(String::NewSymbol("OLED"), constructor);
    

}

Handle<Value> OLED::New(const Arguments& args) {
  HandleScope scope;

  if (args.IsConstructCall()) {
    OLED* obj = new OLED();
    
    
    obj->Wrap(args.This());
    return args.This();
  } else {
    // Invoked as plain function `MyObject(...)`, turn into construct call.
    const int argc = 5;
    Local<Value> argv[argc] = { args[0], args[1], args[2], args[3], args[4] };
    return scope.Close(constructor->NewInstance(argc, argv));
  }
}
Handle<Value> OLED::setup(const Arguments& args) {
    HandleScope scope;
    OLED* obj = ObjectWrap::Unwrap<OLED>(args.This());
    Local<Function> cb = Local<Function>::Cast(args[1]);
    const int argc = 1;
    Local<Value> argv[argc] = {String::New("")};

    if (args.Length() < 2) {
        ThrowException(Exception::TypeError(String::New("Wrong number of arguments")));
        return scope.Close(Undefined());
    }
    
    if(!args[0]->IsObject()) {
        ThrowException(Exception::TypeError(String::New("Wrong type of arguments, must be object")));
        return scope.Close(Undefined());
    }
    Local<Object>  argObj  = args[0]->ToObject();
    obj->csCh = 0;
    if(argObj->Get(String::New("spiCh"))->IsUint32())
        obj->csCh = argObj->Get(String::New("spiCh"))->IntegerValue();
        
    obj->pinRst = 0;    
    if(argObj->Get(String::New("pinRst"))->IsUint32())
        obj->pinRst = argObj->Get(String::New("pinRst"))->IntegerValue();
        
    obj->pinDc = 0;
    if(argObj->Get(String::New("pinDc"))->IsUint32())
        obj->pinDc = argObj->Get(String::New("pinDc"))->IntegerValue();
        
    obj->sizeWidth = 128;
    if(argObj->Get(String::New("sizeWidth"))->IsUint32())
        obj->sizeWidth = argObj->Get(String::New("sizeWidth"))->IntegerValue();
    obj->sizeHeigh = 64;
    if(argObj->Get(String::New("sizeWidth"))->IsUint32())
        obj->sizeHeigh = argObj->Get(String::New("sizeHeigh"))->IntegerValue();
        
    buffer = (uint8_t *) malloc(obj->sizeHeigh * obj->sizeWidth /8);
    memset(buffer, 0x00, obj->sizeHeigh * obj->sizeWidth /8);
    //memcpy(buffer, logo, obj->sizeHeigh * obj->sizeWidth /8);
    obj->rotate = 0;
    obj->textsize = 1;
    obj->cursor_x = 0;
    obj->cursor_y = 0;
    obj->textbgcolor = 0;
    obj->textcolor = 1;
    obj->wrap = 1;
    
    bcm2835_spi_begin();
    bcm2835_spi_setBitOrder(BCM2835_SPI_BIT_ORDER_MSBFIRST);      // The default
    bcm2835_spi_setDataMode(BCM2835_SPI_MODE2);                   // The default
    bcm2835_spi_setClockDivider(BCM2835_SPI_CLOCK_DIVIDER_128 ); //500Khz
    bcm2835_spi_chipSelect(obj->csCh);                      // The default
    bcm2835_spi_setChipSelectPolarity(obj->csCh, LOW);      // the default
    
    //bcm2835_gpio_fsel(obj->pinDc, BCM2835_GPIO_FSEL_INPT);
    bcm2835_gpio_fsel(obj->pinDc, BCM2835_GPIO_FSEL_OUTP);
    //bcm2835_gpio_fsel(obj->pinRst, BCM2835_GPIO_FSEL_INPT);
    bcm2835_gpio_fsel(obj->pinRst, BCM2835_GPIO_FSEL_OUTP);

    bcm2835_gpio_write(obj->pinRst, 0);
    usleep(50000);
    bcm2835_gpio_write(obj->pinRst, 1);
    uint8_t initCmd[] = {
        0xae,//--turn off oled panel
        0x00,//---set low column address
        0x10,//---set high column address
        0x40,//--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)
        0x81,//--set contrast control register
        0xcf, // Set SEG Output Current Brightness
        0xa1,//--Set SEG/Column Mapping     0xa0×óÓÒ·´ÖÃ 0xa1Õý³£
        0xc8,//Set COM/Row Scan Direction   0xc0ÉÏÏÂ·´ÖÃ 0xc8Õý³£
        0xa6,//--set normal display
        0xa8,//--set multiplex ratio(1 to 64)
        0x3f,//--1/64 duty
        0xd3,//-set display offset	Shift Mapping RAM Counter (0x00~0x3F)
        0x00,//-not offset
        0xd5,//--set display clock divide ratio/oscillator frequency
        0x80,//--set divide ratio, Set Clock as 100 Frames/Sec
        0xd9,//--set pre-charge period
        0xf1,//Set Pre-Charge as 15 Clocks & Discharge as 1 Clock
        0xda,//--set com pins hardware configuration
        0x12,
        0xdb,//--set vcomh
        0x40,//Set VCOM Deselect Level
        0x20,//-Set Page Addressing Mode (0x00/0x01/0x02)
        0x02,//
        0x8d,//--set Charge Pump enable/disable
        0x14,//--set(0x10) disable
        0xa4,// Disable Entire Display On (0xa4/0xa5)
        0xa6,// Disable Inverse Display On (0xa6/a7)
        0xaf,//--turn on oled panel
        0x00  //³õÊ¼ÇåÆÁ  
    };
    cmd(obj, initCmd, sizeof initCmd);
    
    if (cb->IsFunction()) {
         // callback not defined, ignore
         cb->Call(Context::GetCurrent()->Global(), argc, argv);
         return scope.Close(Undefined());
    }
    return scope.Close(Undefined());
}
Handle<Value> OLED::writePixel(const Arguments& args) {
    HandleScope scope;
    OLED* obj = ObjectWrap::Unwrap<OLED>(args.This());

    return scope.Close(Undefined());
}

void OLED::cmd(OLED* obj, uint8_t* data, int length)
{
    bcm2835_gpio_write(obj->pinDc, 0);
    bcm2835_spi_transfern((char*)data, length);
}
void OLED::data(OLED* obj, uint8_t* data, int length)
{
    bcm2835_gpio_write(obj->pinDc, 1);
    
    bcm2835_spi_transfern((char*)data, length);
}
void OLED::gotoxy(OLED* obj, int x, int y){
    uint8_t command[] = {0xb0+y, ((x&0xf0)>>4)|0x10, (x&0x0f)|0x01};
    cmd(obj, command, sizeof command);
}
Handle<Value> OLED::gotoxy(const Arguments& args) {
    HandleScope scope;
    OLED* obj = ObjectWrap::Unwrap<OLED>(args.This());
    if(args.Length() == 2 && args[0]->IsUint32() && args[1]->IsUint32()){
        gotoxy(obj, args[0]->IntegerValue(), args[1]->IntegerValue());
    }
    return scope.Close(Undefined());
}
void OLED::drawPixel(OLED* obj, int x, int y, int color)
{
    
    if(x > obj->sizeWidth || y > obj->sizeHeigh || x < 0 || y < 0) return;
    switch (obj->rotate) {
        case 1:
        swap(x, y);
        x = obj->sizeWidth - x - 1;
        break;
        case 2:
            x = obj->sizeWidth - x - 1;
            y = obj->sizeHeigh - y - 1;
        break;
        case 3:
            swap(x, y);
            y = obj->sizeHeigh - y - 1;
        break;
    }  

  // x is which column
    switch (color) 
    {
      case 1:   buffer[x+ (y/8)*obj->sizeWidth] |=  (1 << (y&7)); break;
      case 0:   buffer[x+ (y/8)*obj->sizeWidth] &= ~(1 << (y&7)); break; 
      case -1: buffer[x+ (y/8)*obj->sizeWidth] ^=  (1 << (y&7)); break; 
    }
}
void OLED::display(OLED *obj)
{
    int y,x;
	//uint8_t cmd
	for(y=0; y<obj->sizeHeigh/8; y++)
	{
	    uint8_t scmd[] = {0xb0+y, 0x01, 0x10};
	    cmd(obj, scmd, sizeof scmd);
	    
	    uint8_t dataw[obj->sizeWidth];
		for(x=0; x<obj->sizeWidth;x++)
		    dataw[x] = buffer[x + y*128];
		data(obj, dataw, sizeof dataw);
	}
}
Handle<Value> OLED::display(const Arguments& args) 
{
    HandleScope scope;
    OLED* obj = ObjectWrap::Unwrap<OLED>(args.This());
    if(args[0]->IsObject()){
        Local<Object> bufferObj    = args[0]->ToObject();
        char*         bufferData   = Buffer::Data(bufferObj);
        size_t        bufferLength = Buffer::Length(bufferObj);
       
        if(bufferLength != obj->sizeHeigh*obj->sizeWidth/8){
            ThrowException(Exception::TypeError(String::New("Wrong size of bitmap")));
            return scope.Close(Undefined());
        }
        memcpy(buffer, bufferData, obj->sizeHeigh * obj->sizeWidth/8);
        display(obj);
    } else {
        display(obj);
    }
    return scope.Close(Undefined());
    
    // Actual data
    
}
Handle<Value> OLED::fill(const Arguments& args) 
{
    HandleScope scope;
    OLED* obj = ObjectWrap::Unwrap<OLED>(args.This());
    
    
    
    int bitmap = 0xFF;
    if(args[0]->IsUint32()){
        bitmap = args[0]->IntegerValue();
    }
	memset(buffer, bitmap, obj->sizeWidth*obj->sizeHeigh/8);
	//drawCircle(obj,64, 32, 10, 1);
    display(obj);
    
	return scope.Close(Undefined());
}


Handle<Value> OLED::text(const Arguments& args)
{
    HandleScope scope;
    OLED* obj = ObjectWrap::Unwrap<OLED>(args.This());

   Local<Object>  argObj  = args[1]->ToObject();

    if(argObj->Get(String::New("x"))->IsUint32())
        obj->cursor_x = argObj->Get(String::New("x"))->IntegerValue();
        
    if(argObj->Get(String::New("y"))->IsUint32())
        obj->cursor_y = argObj->Get(String::New("y"))->IntegerValue();
    if(argObj->Get(String::New("textcolor"))->IsUint32())
        obj->textcolor = argObj->Get(String::New("textcolor"))->IntegerValue();
    if(argObj->Get(String::New("textsize"))->IsUint32())
        obj->textsize = argObj->Get(String::New("textsize"))->IntegerValue();
    if(argObj->Get(String::New("textbgcolor"))->IsUint32())
        obj->textbgcolor = argObj->Get(String::New("textbgcolor"))->IntegerValue();
    if(argObj->Get(String::New("wrap"))->IsUint32())
        obj->wrap = argObj->Get(String::New("wrap"))->IntegerValue();
        
    char* strData = strToPtr(args[0], "");

    int i=0;
    while(strData[i] != 0){
        write(obj, strData[i]);
        i++;
    }

    display(obj);
	return scope.Close(Undefined());
}
char *OLED::strToPtr(Local<Value> value, const char *fallback = "") {
    if (value->IsString()) {
        String::AsciiValue string(value);
        char *str = (char *) malloc(string.length() + 1);
        strcpy(str, *string);
        return str;
    }
    char *str = (char *) malloc(strlen(fallback) + 1);
    strcpy(str, fallback);
    return str;
}

void OLED::drawLine(OLED *obj, int x0, int y0, int x1, int y1, int color) 
{
  int steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    swap(x0, x1);
    swap(y0, y1);
  }

  int dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int err = dx / 2;
  int ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    if (steep) {
      drawPixel(obj, y0, x0, color);
    } else {
      drawPixel(obj, x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
      y0 += ystep;
      err += dx;
    }
  }
}
void OLED::drawCircle(OLED *obj, int x0, int y0, int r, int color) 
{
  int f = 1 - r;
  int ddF_x = 1;
  int ddF_y = -2 * r;
  int x = 0;
  int y = r;

  drawPixel(obj, x0  , y0+r, color);
  drawPixel(obj, x0  , y0-r, color);
  drawPixel(obj, x0+r, y0  , color);
  drawPixel(obj, x0-r, y0  , color);

  while (x<y) {
    if (f >= 0) {
      y--;
      ddF_y += 2;
      f += ddF_y;
    }
    x++;
    ddF_x += 2;
    f += ddF_x;
  
    drawPixel(obj, x0 + x, y0 + y, color);
    drawPixel(obj, x0 - x, y0 + y, color);
    drawPixel(obj, x0 + x, y0 - y, color);
    drawPixel(obj, x0 - x, y0 - y, color);
    drawPixel(obj, x0 + y, y0 + x, color);
    drawPixel(obj, x0 - y, y0 + x, color);
    drawPixel(obj, x0 + y, y0 - x, color);
    drawPixel(obj, x0 - y, y0 - x, color);
  }
}

void OLED::drawRect(OLED *obj, int x, int y, int w, int h, int color) 
{
  drawFastHLine(obj, x, y, w, color);
  drawFastHLine(obj, x, y+h-1, w, color);
  drawFastVLine(obj, x, y, h, color);
  drawFastVLine(obj, x+w-1, y, h, color);
}
void OLED::fillRect(OLED *obj, int x, int y, int w, int h, int color) 
{
  // Update in subclasses if desired!
  for (int i=x; i<x+w; i++) {
    drawFastVLine(obj, i, y, h, color);
  }
}

void OLED::drawFastVLine(OLED *obj, int x, int y, int h, int color) 
{
  // Update in subclasses if desired!
  drawLine(obj, x, y, x, y+h-1, color);
}

void OLED::drawFastHLine(OLED *obj, int x, int y, int w, int color) 
{
  // Update in subclasses if desired!
  drawLine(obj, x, y, x+w-1, y, color);
}
// Draw a character
void OLED::drawChar(OLED *obj, unsigned char c) 
{

  if((obj->cursor_x >= obj->sizeWidth)            || // Clip right
     (obj->cursor_y >= obj->sizeHeigh)           || // Clip bottom
     ((obj->cursor_x + 6 * obj->textsize - 1) < 0) || // Clip left
     ((obj->cursor_y + 8 * obj->textsize - 1) < 0))   // Clip top
    return;

  for (int i=0; i<6; i++ ) {
    int line;
    if (i == 5) 
      line = 0x0;
    else 
      line = *(font+(c*5)+i);
    for (int j = 0; j<8; j++) {
      if (line & 0x1) {
        if (obj->textsize == 1) // default size
          drawPixel(obj, obj->cursor_x+i, obj->cursor_y+j, obj->textcolor);
        else {  // big size
          fillRect(obj, obj->cursor_x+(i*obj->textsize), obj->cursor_y+(j*obj->textsize), obj->textsize, obj->textsize, obj->textcolor);
        } 
      } else if (obj->textbgcolor != obj->textcolor) {
        if (obj->textsize == 1) // default size
          drawPixel(obj, obj->cursor_x+i, obj->cursor_y+j, obj->textbgcolor);
        else {  // big size
          fillRect(obj, obj->cursor_x+i*obj->textsize, obj->cursor_y+j*obj->textsize, obj->textsize, obj->textsize, obj->textbgcolor);
        }
      }
      line >>= 1;
    }
  }
}
void OLED::write(OLED *obj, char c) {
  if (c == '\n') {
    obj->cursor_y += obj->textsize*8;
    obj->cursor_x  = 0;
  } else if (c == '\r') {
    // skip em
  } else {
    drawChar(obj, c);
    obj->cursor_x += obj->textsize*6;
    if (obj->wrap && (obj->cursor_x > (obj->sizeWidth - obj->textsize*6))) {
      obj->cursor_y += obj->textsize*8;
      obj->cursor_x = 0;
    }
  }
}

